# Curses library provides a terminal-independent SCREEN PAINTING and KEYBOARD handling
# for text based terminals.
import curses
import random
import time
​
# initscr() returns a window object representing the entire screen; called as STDSCR 
window = curses.initscr()
​
# Echoing of input characters is turned off.
# curses.noecho()
​
#  Set the cursor state. visibility can be set to 0, 1, or 2, for invisible, normal, or very visible.
curses.curs_set(0)
​
# Return a tuple (y, x) of the height and width of the window.
win_height, win_width = window.getmaxyx()
​
#>> curses.newwin(nlines, ncols, begin_y, begin_x)
# Return a new window, whose left-upper corner is at (begin_y, begin_x), and whose height/width is nlines/ncols.
new_win = curses.newwin(win_height, win_width, 0, 0)
​
#   curses.def_prog_mode()
# window.keypad(flag)
#     If flag is True, escape sequences generated by some keys (keypad, function keys) will be interpreted by curses. 
#     If flag is False, escape sequences will be left as is in the input stream.
new_win.keypad(True)
​
# window.timeout(delay)
# The getch() will block for delay milliseconds, and return -1 if there is still no input at the end of that time.
​
new_win.timeout(200)
​
for i in range(win_width-1):
    new_win.addch(0, i, curses.ACS_BOARD)
    new_win.addch(win_height-1,i, curses.ACS_BOARD)
for i in range(win_height-1):
    new_win.addch(i, 0, curses.ACS_BOARD)
    new_win.addch(i, win_width-1, curses.ACS_BOARD)
​
#####
# Now we will define the initial position for the snake
snake_x = win_width/4
snake_y = win_height/2
​
# And then define the coordinates of body parts of the snake
snake = [
    [snake_y,snake_x],
    [snake_y,snake_x-1],
    [snake_y,snake_x-2]
]
​
####
# Now define the initial location for the food
food = [win_height//2, win_width//2]
​
# window.addch(y, x, ch[, attr])
#     Paint character ch at (y, x) with attributes attr, overwriting any character previously painter at that location.
new_win.addch(food[0], food[1], curses.ACS_DIAMOND) # Defining the point with a diamond symbol
​
####
# define the initial direction
key = curses.KEY_RIGHT
​
​
​
######################################333
while True:
    next_key = new_win.getch()  #    return -1 if there is still no input
    key = key if next_key == -1 else next_key
​
    #### LOOSE the game if it touches the boundary
    #  <y_coord touched up and down>   <x_coord touched left & right>  <if snake bites itself>
    if snake[0][0] in [1,win_height-1] or snake[0][1] in [1,win_width-1] or snake[0] in snake[1:]:
        curses.beep()
        time.sleep(2)
        curses.endwin()
        quit()
    ###############################
​
    if key == curses.KEY_DOWN:
        new_head = [snake[0][0] + 1, snake[0][1]]
    if key == curses.KEY_UP:
        new_head = [snake[0][0] - 1, snake[0][1]]
    if key == curses.KEY_LEFT:
        new_head = [snake[0][0], snake[0][1] - 1]
    if key == curses.KEY_RIGHT:
        new_head = [snake[0][0], snake[0][1] + 1]
    
    # move the head in the new direction
    snake.insert(0, new_head)
​
    # if new_head == food:
    if snake[0] == food:
        food = None
        while food is None:
            new_food = [
                random.randint(1, win_height-2),
                random.randint(1, win_width-2)
            ]
            food = new_food if new_food not in snake else None
        
        new_win.addch(food[0], food[1], curses.ACS_DIAMOND)
    else:
        tail = snake.pop()
        new_win.addch(int(tail[0]), int(tail[1]), ' ')
​
    new_win.addch(int(snake[0][0]), int(snake[0][1]), curses.ACS_LANTERN)  
​
​
​
'''
ACS code | Meaning
​
ACS_BBSS alternate name for upper right corner
​
ACS_BLOCK solid square block
​
ACS_BOARD oard of squares
​
ACS_BSBS alternate name for horizontal line
​
ACS_BSSB alternate name for upper left corner
​
ACS_BSSS alternate name for top tee
​
ACS_BTEE bottom tee
​
ACS_BULLET bullet
​
ACS_CKBOARD checker board (stipple)
​
ACS_DARROW arrow pointing down
​
ACS_DEGREE degree symbol
​
ACS_DIAMOND diamond
ACS_GEQUAL greater-than-or-equal-to
​
ACS_HLINE horizontal line
​
ACS_LANTERN lantern symbol
​
ACS_LARROW left arrow
​
ACS_LEQUAL less-than-or-equal-to
​
ACS_LLCORNER lower left-hand corner
​
ACS_LRCORNER lower right-hand corner
​
ACS_LTEE left tee
​
ACS_NEQUAL not-equal sign
​
ACS_PI letter pi
​
ACS_PLMINUS plus-or-minus sign
​
ACS_PLUS big plus sign
​
ACS_RARROW right arrow
​
ACS_RTEE right tee
​
ACS_S1 scan line 1
​
ACS_S3 scan line 3
​
ACS_S7 scan line 7
​
ACS_S9 scan line 9
​
ACS_SBBS alternate name for lower right corner
ACS_SBSB alternate name for vertical line
ACS_SBSS alternate name for right tee
ACS_SSBB alternate name for lower left corner
ACS_SSBS alternate name for bottom tee
ACS_SSSB alternate name for left tee
ACS_SSSS alternate name for crossover or big plus
ACS_UARROW up arrow
ACS_VLINE vertical line
'''
